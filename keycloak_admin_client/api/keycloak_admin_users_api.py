# coding: utf-8

"""
    My Project

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401
import sys  # noqa: F401

# python 2 and python 3 compatibility library
import six

from keycloak_admin_client.api_client import ApiClient
from keycloak_admin_client.exceptions import (
    ApiTypeError,
    ApiValueError
)
from keycloak_admin_client.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    int,
    none_type,
    str,
    validate_and_convert_types
)
from keycloak_admin_client.models import user_representation
from keycloak_admin_client.models import up_config
from keycloak_admin_client.models import user_profile_metadata
from keycloak_admin_client.models import credential_representation
from keycloak_admin_client.models import federated_identity_representation
from keycloak_admin_client.models import group_representation
from keycloak_admin_client.models import user_session_representation


class KeycloakAdminUsersApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

        def __admin_realms_realm_users_count_get(
            self,
            realm,
            **kwargs
        ):
            """Returns the number of users that match the given criteria.  # noqa: E501

            It can be called in three different ways. 1. Donâ€™t specify any criteria and pass {@code null}. The number of all users within that realm will be returned. <p> 2. If {@code search} is specified other criteria such as {@code last} will be ignored even though you set them. The {@code search} string will be matched against the first and last name, the username and the email of a user. <p> 3. If {@code search} is unspecified but any of {@code last}, {@code first}, {@code email} or {@code username} those criteria are matched against their respective fields on a user entity. Combined with a logical and.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_count_get(realm, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):

            Keyword Args:
                email (str): email filter. [optional]
                email_verified (bool): [optional]
                enabled (bool): Boolean representing if user is enabled or not. [optional]
                first_name (str): first name filter. [optional]
                last_name (str): last name filter. [optional]
                q (str): [optional]
                search (str): arbitrary search string for all the fields below. Default search behavior is prefix-based (e.g., foo or foo*). Use *foo* for infix search and \&quot;foo\&quot; for exact search.. [optional]
                username (str): username filter. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                int
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_count_get = Endpoint(
            settings={
                'response_type': (int,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/count',
                'operation_id': 'admin_realms_realm_users_count_get',
                'http_method': 'GET',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'email',
                    'email_verified',
                    'enabled',
                    'first_name',
                    'last_name',
                    'q',
                    'search',
                    'username',
                ],
                'required': [
                    'realm',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'email':
                        (str,),
                    'email_verified':
                        (bool,),
                    'enabled':
                        (bool,),
                    'first_name':
                        (str,),
                    'last_name':
                        (str,),
                    'q':
                        (str,),
                    'search':
                        (str,),
                    'username':
                        (str,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'email': 'email',
                    'email_verified': 'emailVerified',
                    'enabled': 'enabled',
                    'first_name': 'firstName',
                    'last_name': 'lastName',
                    'q': 'q',
                    'search': 'search',
                    'username': 'username',
                },
                'location_map': {
                    'realm': 'path',
                    'email': 'query',
                    'email_verified': 'query',
                    'enabled': 'query',
                    'first_name': 'query',
                    'last_name': 'query',
                    'q': 'query',
                    'search': 'query',
                    'username': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_count_get
        )

        def __admin_realms_realm_users_get(
            self,
            realm,
            **kwargs
        ):
            """Get users Returns a stream of users, filtered according to query parameters.  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_get(realm, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):

            Keyword Args:
                brief_representation (bool): Boolean which defines whether brief representations are returned (default: false). [optional]
                email (str): A String contained in email, or the complete email, if param \&quot;exact\&quot; is true. [optional]
                email_verified (bool): whether the email has been verified. [optional]
                enabled (bool): Boolean representing if user is enabled or not. [optional]
                exact (bool): Boolean which defines whether the params \&quot;last\&quot;, \&quot;first\&quot;, \&quot;email\&quot; and \&quot;username\&quot; must match exactly. [optional]
                first (int): Pagination offset. [optional]
                first_name (str): A String contained in firstName, or the complete firstName, if param \&quot;exact\&quot; is true. [optional]
                idp_alias (str): The alias of an Identity Provider linked to the user. [optional]
                idp_user_id (str): The userId at an Identity Provider linked to the user. [optional]
                last_name (str): A String contained in lastName, or the complete lastName, if param \&quot;exact\&quot; is true. [optional]
                max (int): Maximum results size (defaults to 100). [optional]
                q (str): A query to search for custom attributes, in the format &#39;key1:value2 key2:value2&#39;. [optional]
                search (str): A String contained in username, first or last name, or email. Default search behavior is prefix-based (e.g., foo or foo*). Use *foo* for infix search and \&quot;foo\&quot; for exact search.. [optional]
                username (str): A String contained in username, or the complete username, if param \&quot;exact\&quot; is true. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                [user_representation.UserRepresentation]
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_get = Endpoint(
            settings={
                'response_type': ([user_representation.UserRepresentation],),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users',
                'operation_id': 'admin_realms_realm_users_get',
                'http_method': 'GET',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'brief_representation',
                    'email',
                    'email_verified',
                    'enabled',
                    'exact',
                    'first',
                    'first_name',
                    'idp_alias',
                    'idp_user_id',
                    'last_name',
                    'max',
                    'q',
                    'search',
                    'username',
                ],
                'required': [
                    'realm',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'brief_representation':
                        (bool,),
                    'email':
                        (str,),
                    'email_verified':
                        (bool,),
                    'enabled':
                        (bool,),
                    'exact':
                        (bool,),
                    'first':
                        (int,),
                    'first_name':
                        (str,),
                    'idp_alias':
                        (str,),
                    'idp_user_id':
                        (str,),
                    'last_name':
                        (str,),
                    'max':
                        (int,),
                    'q':
                        (str,),
                    'search':
                        (str,),
                    'username':
                        (str,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'brief_representation': 'briefRepresentation',
                    'email': 'email',
                    'email_verified': 'emailVerified',
                    'enabled': 'enabled',
                    'exact': 'exact',
                    'first': 'first',
                    'first_name': 'firstName',
                    'idp_alias': 'idpAlias',
                    'idp_user_id': 'idpUserId',
                    'last_name': 'lastName',
                    'max': 'max',
                    'q': 'q',
                    'search': 'search',
                    'username': 'username',
                },
                'location_map': {
                    'realm': 'path',
                    'brief_representation': 'query',
                    'email': 'query',
                    'email_verified': 'query',
                    'enabled': 'query',
                    'exact': 'query',
                    'first': 'query',
                    'first_name': 'query',
                    'idp_alias': 'query',
                    'idp_user_id': 'query',
                    'last_name': 'query',
                    'max': 'query',
                    'q': 'query',
                    'search': 'query',
                    'username': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_get
        )

        def __admin_realms_realm_users_post(
            self,
            realm,
            **kwargs
        ):
            """Create a new user Username must be unique.  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_post(realm, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):

            Keyword Args:
                user_representation_user_representation (user_representation.UserRepresentation): [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_post = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users',
                'operation_id': 'admin_realms_realm_users_post',
                'http_method': 'POST',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_representation_user_representation',
                ],
                'required': [
                    'realm',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_representation_user_representation':
                        (user_representation.UserRepresentation,),
                },
                'attribute_map': {
                    'realm': 'realm',
                },
                'location_map': {
                    'realm': 'path',
                    'user_representation_user_representation': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_post
        )

        def __admin_realms_realm_users_profile_get(
            self,
            realm,
            **kwargs
        ):
            """/admin/realms/{realm}/users/profile  # noqa: E501

            Get the configuration for the user profile  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_profile_get(realm, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                up_config.UpConfig
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_profile_get = Endpoint(
            settings={
                'response_type': (up_config.UpConfig,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/profile',
                'operation_id': 'admin_realms_realm_users_profile_get',
                'http_method': 'GET',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                ],
                'required': [
                    'realm',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                },
                'attribute_map': {
                    'realm': 'realm',
                },
                'location_map': {
                    'realm': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_profile_get
        )

        def __admin_realms_realm_users_profile_metadata_get(
            self,
            realm,
            **kwargs
        ):
            """/admin/realms/{realm}/users/profile/metadata  # noqa: E501

            Get the UserProfileMetadata from the configuration  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_profile_metadata_get(realm, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                user_profile_metadata.UserProfileMetadata
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_profile_metadata_get = Endpoint(
            settings={
                'response_type': (user_profile_metadata.UserProfileMetadata,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/profile/metadata',
                'operation_id': 'admin_realms_realm_users_profile_metadata_get',
                'http_method': 'GET',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                ],
                'required': [
                    'realm',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                },
                'attribute_map': {
                    'realm': 'realm',
                },
                'location_map': {
                    'realm': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_profile_metadata_get
        )

        def __admin_realms_realm_users_profile_put(
            self,
            realm,
            **kwargs
        ):
            """/admin/realms/{realm}/users/profile  # noqa: E501

            Set the configuration for the user profile  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_profile_put(realm, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):

            Keyword Args:
                up_config_up_config (up_config.UpConfig): [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                up_config.UpConfig
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_profile_put = Endpoint(
            settings={
                'response_type': (up_config.UpConfig,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/profile',
                'operation_id': 'admin_realms_realm_users_profile_put',
                'http_method': 'PUT',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'up_config_up_config',
                ],
                'required': [
                    'realm',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'up_config_up_config':
                        (up_config.UpConfig,),
                },
                'attribute_map': {
                    'realm': 'realm',
                },
                'location_map': {
                    'realm': 'path',
                    'up_config_up_config': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_profile_put
        )

        def __admin_realms_realm_users_user_id_configured_user_storage_credential_types_get(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """Return credential types, which are provided by the user storage where user is stored.  # noqa: E501

            Returned values can contain for example \"password\", \"otp\" etc. This will always return empty list for \"local\" users, which are not backed by any user storage  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_configured_user_storage_credential_types_get(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                [str]
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_configured_user_storage_credential_types_get = Endpoint(
            settings={
                'response_type': ([str],),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/configured-user-storage-credential-types',
                'operation_id': 'admin_realms_realm_users_user_id_configured_user_storage_credential_types_get',
                'http_method': 'GET',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_configured_user_storage_credential_types_get
        )

        def __admin_realms_realm_users_user_id_consents_client_delete(
            self,
            client,
            realm,
            user_id,
            **kwargs
        ):
            """Revoke consent and offline tokens for particular client from user  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_consents_client_delete(client, realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                client (str): Client id
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['client'] = \
                client
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_consents_client_delete = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/consents/{client}',
                'operation_id': 'admin_realms_realm_users_user_id_consents_client_delete',
                'http_method': 'DELETE',
                'servers': [],
            },
            params_map={
                'all': [
                    'client',
                    'realm',
                    'user_id',
                ],
                'required': [
                    'client',
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'client':
                        (str,),
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'client': 'client',
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'client': 'path',
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_consents_client_delete
        )

        def __admin_realms_realm_users_user_id_consents_get(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """Get consents granted by the user  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_consents_get(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                [{str: (str,)}]
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_consents_get = Endpoint(
            settings={
                'response_type': ([{str: (str,)}],),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/consents',
                'operation_id': 'admin_realms_realm_users_user_id_consents_get',
                'http_method': 'GET',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_consents_get
        )

        def __admin_realms_realm_users_user_id_credentials_credential_id_delete(
            self,
            credential_id,
            realm,
            user_id,
            **kwargs
        ):
            """Remove a credential for a user  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_credentials_credential_id_delete(credential_id, realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                credential_id (str):
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['credential_id'] = \
                credential_id
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_credentials_credential_id_delete = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/credentials/{credentialId}',
                'operation_id': 'admin_realms_realm_users_user_id_credentials_credential_id_delete',
                'http_method': 'DELETE',
                'servers': [],
            },
            params_map={
                'all': [
                    'credential_id',
                    'realm',
                    'user_id',
                ],
                'required': [
                    'credential_id',
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'credential_id':
                        (str,),
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'credential_id': 'credentialId',
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'credential_id': 'path',
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_credentials_credential_id_delete
        )

        def __admin_realms_realm_users_user_id_credentials_credential_id_move_after_new_previous_credential_id_post(
            self,
            credential_id,
            new_previous_credential_id,
            realm,
            user_id,
            **kwargs
        ):
            """Move a credential to a position behind another credential  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_credentials_credential_id_move_after_new_previous_credential_id_post(credential_id, new_previous_credential_id, realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                credential_id (str): The credential to move
                new_previous_credential_id (str): The credential that will be the previous element in the list. If set to null, the moved credential will be the first element in the list.
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['credential_id'] = \
                credential_id
            kwargs['new_previous_credential_id'] = \
                new_previous_credential_id
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_credentials_credential_id_move_after_new_previous_credential_id_post = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/credentials/{credentialId}/moveAfter/{newPreviousCredentialId}',
                'operation_id': 'admin_realms_realm_users_user_id_credentials_credential_id_move_after_new_previous_credential_id_post',
                'http_method': 'POST',
                'servers': [],
            },
            params_map={
                'all': [
                    'credential_id',
                    'new_previous_credential_id',
                    'realm',
                    'user_id',
                ],
                'required': [
                    'credential_id',
                    'new_previous_credential_id',
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'credential_id':
                        (str,),
                    'new_previous_credential_id':
                        (str,),
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'credential_id': 'credentialId',
                    'new_previous_credential_id': 'newPreviousCredentialId',
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'credential_id': 'path',
                    'new_previous_credential_id': 'path',
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_credentials_credential_id_move_after_new_previous_credential_id_post
        )

        def __admin_realms_realm_users_user_id_credentials_credential_id_move_to_first_post(
            self,
            credential_id,
            realm,
            user_id,
            **kwargs
        ):
            """Move a credential to a first position in the credentials list of the user  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_credentials_credential_id_move_to_first_post(credential_id, realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                credential_id (str): The credential to move
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['credential_id'] = \
                credential_id
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_credentials_credential_id_move_to_first_post = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/credentials/{credentialId}/moveToFirst',
                'operation_id': 'admin_realms_realm_users_user_id_credentials_credential_id_move_to_first_post',
                'http_method': 'POST',
                'servers': [],
            },
            params_map={
                'all': [
                    'credential_id',
                    'realm',
                    'user_id',
                ],
                'required': [
                    'credential_id',
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'credential_id':
                        (str,),
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'credential_id': 'credentialId',
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'credential_id': 'path',
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_credentials_credential_id_move_to_first_post
        )

        def __admin_realms_realm_users_user_id_credentials_credential_id_user_label_put(
            self,
            credential_id,
            realm,
            user_id,
            **kwargs
        ):
            """Update a credential label for a user  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_credentials_credential_id_user_label_put(credential_id, realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                credential_id (str):
                realm (str):
                user_id (str):

            Keyword Args:
                body (str): [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['credential_id'] = \
                credential_id
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_credentials_credential_id_user_label_put = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/credentials/{credentialId}/userLabel',
                'operation_id': 'admin_realms_realm_users_user_id_credentials_credential_id_user_label_put',
                'http_method': 'PUT',
                'servers': [],
            },
            params_map={
                'all': [
                    'credential_id',
                    'realm',
                    'user_id',
                    'body',
                ],
                'required': [
                    'credential_id',
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'credential_id':
                        (str,),
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                    'body':
                        (str,),
                },
                'attribute_map': {
                    'credential_id': 'credentialId',
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'credential_id': 'path',
                    'realm': 'path',
                    'user_id': 'path',
                    'body': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'text/plain'
                ]
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_credentials_credential_id_user_label_put
        )

        def __admin_realms_realm_users_user_id_credentials_get(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """/admin/realms/{realm}/users/{user-id}/credentials  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_credentials_get(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                [credential_representation.CredentialRepresentation]
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_credentials_get = Endpoint(
            settings={
                'response_type': ([credential_representation.CredentialRepresentation],),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/credentials',
                'operation_id': 'admin_realms_realm_users_user_id_credentials_get',
                'http_method': 'GET',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_credentials_get
        )

        def __admin_realms_realm_users_user_id_delete(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """Delete the user  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_delete(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_delete = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}',
                'operation_id': 'admin_realms_realm_users_user_id_delete',
                'http_method': 'DELETE',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_delete
        )

        def __admin_realms_realm_users_user_id_disable_credential_types_put(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """Disable all credentials for a user of a specific type  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_disable_credential_types_put(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                request_body ([str]): [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_disable_credential_types_put = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/disable-credential-types',
                'operation_id': 'admin_realms_realm_users_user_id_disable_credential_types_put',
                'http_method': 'PUT',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                    'request_body',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                    'request_body':
                        ([str],),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                    'request_body': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_disable_credential_types_put
        )

        def __admin_realms_realm_users_user_id_execute_actions_email_put(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """Send an email to the user with a link they can click to execute particular actions.  # noqa: E501

            An email contains a link the user can click to perform a set of required actions. The redirectUri and clientId parameters are optional. If no redirect is given, then there will be no link back to click after actions have completed. Redirect uri must be a valid uri for the particular clientId.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_execute_actions_email_put(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                client_id (str): Client id. [optional]
                lifespan (int): Number of seconds after which the generated token expires. [optional]
                redirect_uri (str): Redirect uri. [optional]
                request_body ([str]): [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_execute_actions_email_put = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/execute-actions-email',
                'operation_id': 'admin_realms_realm_users_user_id_execute_actions_email_put',
                'http_method': 'PUT',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                    'client_id',
                    'lifespan',
                    'redirect_uri',
                    'request_body',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                    'client_id':
                        (str,),
                    'lifespan':
                        (int,),
                    'redirect_uri':
                        (str,),
                    'request_body':
                        ([str],),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                    'client_id': 'client_id',
                    'lifespan': 'lifespan',
                    'redirect_uri': 'redirect_uri',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                    'client_id': 'query',
                    'lifespan': 'query',
                    'redirect_uri': 'query',
                    'request_body': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_execute_actions_email_put
        )

        def __admin_realms_realm_users_user_id_federated_identity_get(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """Get social logins associated with the user  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_federated_identity_get(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                [federated_identity_representation.FederatedIdentityRepresentation]
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_federated_identity_get = Endpoint(
            settings={
                'response_type': ([federated_identity_representation.FederatedIdentityRepresentation],),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/federated-identity',
                'operation_id': 'admin_realms_realm_users_user_id_federated_identity_get',
                'http_method': 'GET',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_federated_identity_get
        )

        def __admin_realms_realm_users_user_id_federated_identity_provider_delete(
            self,
            provider,
            realm,
            user_id,
            **kwargs
        ):
            """Remove a social login provider from user  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_federated_identity_provider_delete(provider, realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                provider (str): Social login provider id
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['provider'] = \
                provider
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_federated_identity_provider_delete = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/federated-identity/{provider}',
                'operation_id': 'admin_realms_realm_users_user_id_federated_identity_provider_delete',
                'http_method': 'DELETE',
                'servers': [],
            },
            params_map={
                'all': [
                    'provider',
                    'realm',
                    'user_id',
                ],
                'required': [
                    'provider',
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'provider':
                        (str,),
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'provider': 'provider',
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'provider': 'path',
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_federated_identity_provider_delete
        )

        def __admin_realms_realm_users_user_id_federated_identity_provider_post(
            self,
            provider,
            realm,
            user_id,
            **kwargs
        ):
            """Add a social login provider to the user  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_federated_identity_provider_post(provider, realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                provider (str): Social login provider id
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['provider'] = \
                provider
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_federated_identity_provider_post = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/federated-identity/{provider}',
                'operation_id': 'admin_realms_realm_users_user_id_federated_identity_provider_post',
                'http_method': 'POST',
                'servers': [],
            },
            params_map={
                'all': [
                    'provider',
                    'realm',
                    'user_id',
                ],
                'required': [
                    'provider',
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'provider':
                        (str,),
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'provider': 'provider',
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'provider': 'path',
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_federated_identity_provider_post
        )

        def __admin_realms_realm_users_user_id_get(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """Get representation of the user  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_get(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                user_profile_metadata (bool): Indicates if the user profile metadata should be added to the response. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                user_representation.UserRepresentation
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_get = Endpoint(
            settings={
                'response_type': (user_representation.UserRepresentation,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}',
                'operation_id': 'admin_realms_realm_users_user_id_get',
                'http_method': 'GET',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                    'user_profile_metadata',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                    'user_profile_metadata':
                        (bool,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                    'user_profile_metadata': 'userProfileMetadata',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                    'user_profile_metadata': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_get
        )

        def __admin_realms_realm_users_user_id_groups_count_get(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """/admin/realms/{realm}/users/{user-id}/groups/count  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_groups_count_get(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                search (str): [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                {str: (int,)}
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_groups_count_get = Endpoint(
            settings={
                'response_type': ({str: (int,)},),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/groups/count',
                'operation_id': 'admin_realms_realm_users_user_id_groups_count_get',
                'http_method': 'GET',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                    'search',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                    'search':
                        (str,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                    'search': 'search',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                    'search': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_groups_count_get
        )

        def __admin_realms_realm_users_user_id_groups_get(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """/admin/realms/{realm}/users/{user-id}/groups  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_groups_get(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                brief_representation (bool): [optional] if omitted the server will use the default value of True
                first (int): [optional]
                max (int): [optional]
                search (str): [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                [group_representation.GroupRepresentation]
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_groups_get = Endpoint(
            settings={
                'response_type': ([group_representation.GroupRepresentation],),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/groups',
                'operation_id': 'admin_realms_realm_users_user_id_groups_get',
                'http_method': 'GET',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                    'brief_representation',
                    'first',
                    'max',
                    'search',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                    'brief_representation':
                        (bool,),
                    'first':
                        (int,),
                    'max':
                        (int,),
                    'search':
                        (str,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                    'brief_representation': 'briefRepresentation',
                    'first': 'first',
                    'max': 'max',
                    'search': 'search',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                    'brief_representation': 'query',
                    'first': 'query',
                    'max': 'query',
                    'search': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_groups_get
        )

        def __admin_realms_realm_users_user_id_groups_group_id_delete(
            self,
            group_id,
            realm,
            user_id,
            **kwargs
        ):
            """/admin/realms/{realm}/users/{user-id}/groups/{groupId}  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_groups_group_id_delete(group_id, realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                group_id (str):
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['group_id'] = \
                group_id
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_groups_group_id_delete = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/groups/{groupId}',
                'operation_id': 'admin_realms_realm_users_user_id_groups_group_id_delete',
                'http_method': 'DELETE',
                'servers': [],
            },
            params_map={
                'all': [
                    'group_id',
                    'realm',
                    'user_id',
                ],
                'required': [
                    'group_id',
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'group_id':
                        (str,),
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'group_id': 'groupId',
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'group_id': 'path',
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_groups_group_id_delete
        )

        def __admin_realms_realm_users_user_id_groups_group_id_put(
            self,
            group_id,
            realm,
            user_id,
            **kwargs
        ):
            """/admin/realms/{realm}/users/{user-id}/groups/{groupId}  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_groups_group_id_put(group_id, realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                group_id (str):
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['group_id'] = \
                group_id
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_groups_group_id_put = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/groups/{groupId}',
                'operation_id': 'admin_realms_realm_users_user_id_groups_group_id_put',
                'http_method': 'PUT',
                'servers': [],
            },
            params_map={
                'all': [
                    'group_id',
                    'realm',
                    'user_id',
                ],
                'required': [
                    'group_id',
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'group_id':
                        (str,),
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'group_id': 'groupId',
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'group_id': 'path',
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_groups_group_id_put
        )

        def __admin_realms_realm_users_user_id_impersonation_post(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """Impersonate the user  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_impersonation_post(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                {str: (str,)}
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_impersonation_post = Endpoint(
            settings={
                'response_type': ({str: (str,)},),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/impersonation',
                'operation_id': 'admin_realms_realm_users_user_id_impersonation_post',
                'http_method': 'POST',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_impersonation_post
        )

        def __admin_realms_realm_users_user_id_logout_post(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """Remove all user sessions associated with the user Also send notification to all clients that have an admin URL to invalidate the sessions for the particular user.  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_logout_post(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_logout_post = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/logout',
                'operation_id': 'admin_realms_realm_users_user_id_logout_post',
                'http_method': 'POST',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_logout_post
        )

        def __admin_realms_realm_users_user_id_offline_sessions_client_uuid_get(
            self,
            client_uuid,
            realm,
            user_id,
            **kwargs
        ):
            """Get offline sessions associated with the user and client  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_offline_sessions_client_uuid_get(client_uuid, realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                client_uuid (str):
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                [user_session_representation.UserSessionRepresentation]
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['client_uuid'] = \
                client_uuid
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_offline_sessions_client_uuid_get = Endpoint(
            settings={
                'response_type': ([user_session_representation.UserSessionRepresentation],),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/offline-sessions/{clientUuid}',
                'operation_id': 'admin_realms_realm_users_user_id_offline_sessions_client_uuid_get',
                'http_method': 'GET',
                'servers': [],
            },
            params_map={
                'all': [
                    'client_uuid',
                    'realm',
                    'user_id',
                ],
                'required': [
                    'client_uuid',
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'client_uuid':
                        (str,),
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'client_uuid': 'clientUuid',
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'client_uuid': 'path',
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_offline_sessions_client_uuid_get
        )

        def __admin_realms_realm_users_user_id_put(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """Update the user  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_put(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                user_representation_user_representation (user_representation.UserRepresentation): [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_put = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}',
                'operation_id': 'admin_realms_realm_users_user_id_put',
                'http_method': 'PUT',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                    'user_representation_user_representation',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                    'user_representation_user_representation':
                        (user_representation.UserRepresentation,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                    'user_representation_user_representation': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_put
        )

        def __admin_realms_realm_users_user_id_reset_password_email_put(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """Send an email to the user with a link they can click to reset their password.  # noqa: E501

            The redirectUri and clientId parameters are optional. The default for the redirect is the account client. This endpoint has been deprecated.  Please use the execute-actions-email passing a list with UPDATE_PASSWORD within it.  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_reset_password_email_put(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                client_id (str): client id. [optional]
                redirect_uri (str): redirect uri. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_reset_password_email_put = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/reset-password-email',
                'operation_id': 'admin_realms_realm_users_user_id_reset_password_email_put',
                'http_method': 'PUT',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                    'client_id',
                    'redirect_uri',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                    'client_id':
                        (str,),
                    'redirect_uri':
                        (str,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                    'client_id': 'client_id',
                    'redirect_uri': 'redirect_uri',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                    'client_id': 'query',
                    'redirect_uri': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_reset_password_email_put
        )

        def __admin_realms_realm_users_user_id_reset_password_put(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """Set up a new password for the user.  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_reset_password_put(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                credential_representation_credential_representation (credential_representation.CredentialRepresentation): [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_reset_password_put = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/reset-password',
                'operation_id': 'admin_realms_realm_users_user_id_reset_password_put',
                'http_method': 'PUT',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                    'credential_representation_credential_representation',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                    'credential_representation_credential_representation':
                        (credential_representation.CredentialRepresentation,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                    'credential_representation_credential_representation': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_reset_password_put
        )

        def __admin_realms_realm_users_user_id_send_verify_email_put(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """Send an email-verification email to the user An email contains a link the user can click to verify their email address.  # noqa: E501

            The redirectUri, clientId and lifespan parameters are optional. The default for the redirect is the account client. The default for the lifespan is 12 hours  # noqa: E501
            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_send_verify_email_put(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                client_id (str): Client id. [optional]
                lifespan (int): Number of seconds after which the generated token expires. [optional]
                redirect_uri (str): Redirect uri. [optional]
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                bool, date, datetime, dict, float, int, list, str
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_send_verify_email_put = Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str,),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/send-verify-email',
                'operation_id': 'admin_realms_realm_users_user_id_send_verify_email_put',
                'http_method': 'PUT',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                    'client_id',
                    'lifespan',
                    'redirect_uri',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                    'client_id':
                        (str,),
                    'lifespan':
                        (int,),
                    'redirect_uri':
                        (str,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                    'client_id': 'client_id',
                    'lifespan': 'lifespan',
                    'redirect_uri': 'redirect_uri',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                    'client_id': 'query',
                    'lifespan': 'query',
                    'redirect_uri': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_send_verify_email_put
        )

        def __admin_realms_realm_users_user_id_sessions_get(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """Get sessions associated with the user  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_sessions_get(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                [user_session_representation.UserSessionRepresentation]
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_sessions_get = Endpoint(
            settings={
                'response_type': ([user_session_representation.UserSessionRepresentation],),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/sessions',
                'operation_id': 'admin_realms_realm_users_user_id_sessions_get',
                'http_method': 'GET',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_sessions_get
        )

        def __admin_realms_realm_users_user_id_unmanaged_attributes_get(
            self,
            realm,
            user_id,
            **kwargs
        ):
            """/admin/realms/{realm}/users/{user-id}/unmanagedAttributes  # noqa: E501

            This method makes a synchronous HTTP request by default. To make an
            asynchronous HTTP request, please pass async_req=True
            >>> thread = api.admin_realms_realm_users_user_id_unmanaged_attributes_get(realm, user_id, async_req=True)
            >>> result = thread.get()

            Args:
                realm (str):
                user_id (str):

            Keyword Args:
                _return_http_data_only (bool): response data without head status
                    code and headers. Default is True.
                _preload_content (bool): if False, the urllib3.HTTPResponse object
                    will be returned without reading/decoding response data.
                    Default is True.
                _request_timeout (float/tuple): timeout setting for this request. If one
                    number provided, it will be total request timeout. It can also
                    be a pair (tuple) of (connection, read) timeouts.
                    Default is None.
                _check_input_type (bool): specifies if type checking
                    should be done one the data sent to the server.
                    Default is True.
                _check_return_type (bool): specifies if type checking
                    should be done one the data received from the server.
                    Default is True.
                _host_index (int): specifies the index of the server
                    that we want to use.
                    Default is 0.
                async_req (bool): execute request asynchronously

            Returns:
                {str: ([str],)}
                    If the method is called asynchronously, returns the request
                    thread.
            """
            kwargs['async_req'] = kwargs.get(
                'async_req', False
            )
            kwargs['_return_http_data_only'] = kwargs.get(
                '_return_http_data_only', True
            )
            kwargs['_preload_content'] = kwargs.get(
                '_preload_content', True
            )
            kwargs['_request_timeout'] = kwargs.get(
                '_request_timeout', None
            )
            kwargs['_check_input_type'] = kwargs.get(
                '_check_input_type', True
            )
            kwargs['_check_return_type'] = kwargs.get(
                '_check_return_type', True
            )
            kwargs['_host_index'] = kwargs.get('_host_index', 0)
            kwargs['realm'] = \
                realm
            kwargs['user_id'] = \
                user_id
            return self.call_with_http_info(**kwargs)

        self.admin_realms_realm_users_user_id_unmanaged_attributes_get = Endpoint(
            settings={
                'response_type': ({str: ([str],)},),
                'auth': [],
                'endpoint_path': '/admin/realms/{realm}/users/{user-id}/unmanagedAttributes',
                'operation_id': 'admin_realms_realm_users_user_id_unmanaged_attributes_get',
                'http_method': 'GET',
                'servers': [],
            },
            params_map={
                'all': [
                    'realm',
                    'user_id',
                ],
                'required': [
                    'realm',
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'realm':
                        (str,),
                    'user_id':
                        (str,),
                },
                'attribute_map': {
                    'realm': 'realm',
                    'user_id': 'user-id',
                },
                'location_map': {
                    'realm': 'path',
                    'user_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client,
            callable=__admin_realms_realm_users_user_id_unmanaged_attributes_get
        )


class Endpoint(object):
    def __init__(self, settings=None, params_map=None, root_map=None,
                 headers_map=None, api_client=None, callable=None):
        """Creates an endpoint

        Args:
            settings (dict): see below key value pairs
                'response_type' (tuple/None): response type
                'auth' (list): a list of auth type keys
                'endpoint_path' (str): the endpoint path
                'operation_id' (str): endpoint string identifier
                'http_method' (str): POST/PUT/PATCH/GET etc
                'servers' (list): list of str servers that this endpoint is at
            params_map (dict): see below key value pairs
                'all' (list): list of str endpoint parameter names
                'required' (list): list of required parameter names
                'nullable' (list): list of nullable parameter names
                'enum' (list): list of parameters with enum values
                'validation' (list): list of parameters with validations
            root_map
                'validations' (dict): the dict mapping endpoint parameter tuple
                    paths to their validation dictionaries
                'allowed_values' (dict): the dict mapping endpoint parameter
                    tuple paths to their allowed_values (enum) dictionaries
                'openapi_types' (dict): param_name to openapi type
                'attribute_map' (dict): param_name to camelCase name
                'location_map' (dict): param_name to  'body', 'file', 'form',
                    'header', 'path', 'query'
                collection_format_map (dict): param_name to `csv` etc.
            headers_map (dict): see below key value pairs
                'accept' (list): list of Accept header strings
                'content_type' (list): list of Content-Type header strings
            api_client (ApiClient) api client instance
            callable (function): the function which is invoked when the
                Endpoint is called
        """
        self.settings = settings
        self.params_map = params_map
        self.params_map['all'].extend([
            'async_req',
            '_host_index',
            '_preload_content',
            '_request_timeout',
            '_return_http_data_only',
            '_check_input_type',
            '_check_return_type'
        ])
        self.params_map['nullable'].extend(['_request_timeout'])
        self.validations = root_map['validations']
        self.allowed_values = root_map['allowed_values']
        self.openapi_types = root_map['openapi_types']
        extra_types = {
            'async_req': (bool,),
            '_host_index': (int,),
            '_preload_content': (bool,),
            '_request_timeout': (none_type, int, (int,), [int]),
            '_return_http_data_only': (bool,),
            '_check_input_type': (bool,),
            '_check_return_type': (bool,)
        }
        self.openapi_types.update(extra_types)
        self.attribute_map = root_map['attribute_map']
        self.location_map = root_map['location_map']
        self.collection_format_map = root_map['collection_format_map']
        self.headers_map = headers_map
        self.api_client = api_client
        self.callable = callable

    def __validate_inputs(self, kwargs):
        for param in self.params_map['enum']:
            if param in kwargs:
                check_allowed_values(
                    self.allowed_values,
                    (param,),
                    kwargs[param]
                )

        for param in self.params_map['validation']:
            if param in kwargs:
                check_validations(
                    self.validations,
                    (param,),
                    kwargs[param]
                )

        if kwargs['_check_input_type'] is False:
            return

        for key, value in six.iteritems(kwargs):
            fixed_val = validate_and_convert_types(
                value,
                self.openapi_types[key],
                [key],
                False,
                kwargs['_check_input_type'],
                configuration=self.api_client.configuration
            )
            kwargs[key] = fixed_val

    def __gather_params(self, kwargs):
        params = {
            'body': None,
            'collection_format': {},
            'file': {},
            'form': [],
            'header': {},
            'path': {},
            'query': []
        }

        for param_name, param_value in six.iteritems(kwargs):
            param_location = self.location_map.get(param_name)
            if param_location is None:
                continue
            if param_location:
                if param_location == 'body':
                    params['body'] = param_value
                    continue
                base_name = self.attribute_map[param_name]
                if (param_location == 'form' and
                        self.openapi_types[param_name] == (file_type,)):
                    params['file'][param_name] = [param_value]
                elif (param_location == 'form' and
                        self.openapi_types[param_name] == ([file_type],)):
                    # param_value is already a list
                    params['file'][param_name] = param_value
                elif param_location in {'form', 'query'}:
                    param_value_full = (base_name, param_value)
                    params[param_location].append(param_value_full)
                if param_location not in {'form', 'query'}:
                    params[param_location][base_name] = param_value
                collection_format = self.collection_format_map.get(param_name)
                if collection_format:
                    params['collection_format'][base_name] = collection_format

        return params

    def __call__(self, *args, **kwargs):
        """ This method is invoked when endpoints are called
        Example:
        pet_api = PetApi()
        pet_api.add_pet  # this is an instance of the class Endpoint
        pet_api.add_pet()  # this invokes pet_api.add_pet.__call__()
        which then invokes the callable functions stored in that endpoint at
        pet_api.add_pet.callable or self.callable in this class
        """
        return self.callable(self, *args, **kwargs)

    def call_with_http_info(self, **kwargs):

        try:
            _host = self.settings['servers'][kwargs['_host_index']]
        except IndexError:
            if self.settings['servers']:
                raise ApiValueError(
                    "Invalid host index. Must be 0 <= index < %s" %
                    len(self.settings['servers'])
                )
            _host = None

        for key, value in six.iteritems(kwargs):
            if key not in self.params_map['all']:
                raise ApiTypeError(
                    "Got an unexpected parameter '%s'"
                    " to method `%s`" %
                    (key, self.settings['operation_id'])
                )
            # only throw this nullable ApiValueError if _check_input_type
            # is False, if _check_input_type==True we catch this case
            # in self.__validate_inputs
            if (key not in self.params_map['nullable'] and value is None
                    and kwargs['_check_input_type'] is False):
                raise ApiValueError(
                    "Value may not be None for non-nullable parameter `%s`"
                    " when calling `%s`" %
                    (key, self.settings['operation_id'])
                )

        for key in self.params_map['required']:
            if key not in kwargs.keys():
                raise ApiValueError(
                    "Missing the required parameter `%s` when calling "
                    "`%s`" % (key, self.settings['operation_id'])
                )

        self.__validate_inputs(kwargs)

        params = self.__gather_params(kwargs)

        accept_headers_list = self.headers_map['accept']
        if accept_headers_list:
            params['header']['Accept'] = self.api_client.select_header_accept(
                accept_headers_list)

        content_type_headers_list = self.headers_map['content_type']
        if content_type_headers_list:
            header_list = self.api_client.select_header_content_type(
                content_type_headers_list)
            params['header']['Content-Type'] = header_list

        return self.api_client.call_api(
            self.settings['endpoint_path'], self.settings['http_method'],
            params['path'],
            params['query'],
            params['header'],
            body=params['body'],
            post_params=params['form'],
            files=params['file'],
            response_type=self.settings['response_type'],
            auth_settings=self.settings['auth'],
            async_req=kwargs['async_req'],
            _check_type=kwargs['_check_return_type'],
            _return_http_data_only=kwargs['_return_http_data_only'],
            _preload_content=kwargs['_preload_content'],
            _request_timeout=kwargs['_request_timeout'],
            _host=_host,
            collection_formats=params['collection_format'])
